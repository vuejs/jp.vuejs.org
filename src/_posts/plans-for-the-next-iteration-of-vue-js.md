---
title: Vue.js における次のイテレーションの計画
date: 2018-10-01 00:00:00
---

*このブログはこちらの翻訳ブログです。*
[Plans for the Next Iteration of Vue\.js – The Vue Point – Medium](https://medium.com/the-vue-point/plans-for-the-next-iteration-of-vue-js-777ffea6fabf)

# Vue.js における次のイテレーションの計画

先週の [Vue.js London](https://vuejs.london/summary/) で、私は Vue の次のメジャーバージョンについて簡単なプレビューを行いました。このポストでは、計画の詳細な概要を提供します。

![](https://cdn-images-1.medium.com/max/1600/1*vFC8tDUGLlXIiqT7ymf3xg.png)

## なぜ新しいメジャーバージョンを？

Vue 2.0 はちょうど2年前にリリースされました（時が経つのは早いものです！）。この期間中、core は下位互換性を維持しながら5つのマイナーリリースを行いました。他にも改善をもたらすアイデアはありましたが、それらは破壊的な変更を伴うために、延期されてきました。同時に、JavaScript エコシステムと言語そのものが急速に進化しています。ワークフローを強化するツールが大きく改善されたこと、また多くの新しい言語機能によって、Vue が対処しようとしている問題を、より簡単・完全・効率的に解決できるようになりました。エキサイティングなのは、ES2015 が主要なブラウザでサポートされるようになることです。Vue 3.0 は、これらの新しい言語機能を活用して、Vue コアの小型化、高速化、および強力化を目指しています。

Vue 3.0 は現在プロトタイプ段階にあり、私たちは既に 2.x で機能的に近いランタイムを実装しています。**下記の項目の多くはすでに実装されているか、実行可能なことが確認されています。未だ実施されていないか、検討段階にあるものには*印がついています。**

# 詳細

## 高レベル API の変更

*TL;DR: render function API と scoped-slots syntax を除き、その全てが互換性を維持されているか、2.x 互換にすることができます。*

これは新しいメジャーバージョンのため、いくつかの破壊的な変更が起こるでしょう。しかし、私たちは下位互換性を真剣に受け止めているので、なるべく早くこれらの変更についてお知らせしたいと思います。現在計画されている public API の変更点は次のとおりです。

- テンプレートの構文は 99％ 今まで通りです。scoped-slots syntax には微妙な微調整があるかもしれませんが、それ以外にテンプレートの変更は計画されていません。

- 3.0 は、あらゆる transpilation や stage-x features を必要とせずに、ネイティブ ES2015 で快適に使用できる API を提供することを目的として、クラスベースのコンポーネントをネイティブにサポートします。現在のほとんどのオプションは、クラスベースの API に妥当にマッピングされます。class fields や decorator などの stage-x features は、記述体験を向上させるためにオプションとして使用できるようになります。さらに、API は TypeScript 型推論を考慮して設計されます。3.x コードベースそのものも TypeScript で記述されるので、TypeScript のサポートも向上します。（とはいえ、アプリケーションで TypeScript を使用することは完全に任意です）

- 2.x のオブジェクトベースのコンポーネントは、内部的なクラスベースへの変換を通じて引き続き利用可能です。

- Mixins はサポートされ続けます。 *

- トップレベル API が大幅に見直され、プラグインのインストール時に Vue ランタイムをグローバルに変更しなくなる代わりに、プラグインはコンポーネントツリーに対して適用 (applied and scoped) されます。これにより、特定のプラグインに依存するコンポーネントのテストが容易になるほか、異なるプラグインを扱う複数の Vue アプリケーションを1つのページにマウントすることが単一の Vue ランタイムで可能になります。*

- 関数型コンポーネントは遂に単なる関数になります。ただし、非同期コンポーネントに関してはヘルパ関数を使って明示的に作成する必要があります。

- 最も多くの変更を受ける部分は、render 関数の中で使われる Virtual DOM のフォーマットです。私たちは現在、主要なライブラリ作者からのフィードバックを集めており、変更内容が確固たるものになり次第詳細を共有しますが、あなたが手書きの (JSX でない) render 関数に大きく依存していない限りは、そこそこ明快にアップグレードできるはずだと考えています。

## ソースコードアーキテクチャ

*TL;DR: より良く分離された内部モジュール、TypeScript、よりコントリビューションしやすくなるコードベース。*

よりクリーンでメンテナブルなアーキテクチャのために、私たちは 3.0 を最初から書き直しています。特に、よりコントリビューションしやすくなることを心がけています。また複雑さのスコープを分割するため、いくつかの内部機能を個々のパッケージへと切り出しています。たとえば、observer モジュールは独自のパブリック API とテストを持つ独自のパッケージになります。しかしこれらは、framework-level-API には影響しません。Vue を使用するために個々のパッケージをいちいちインポートする必要もなく、最終的な Vue のパッケージがそれらの内部パッケージを使って組み立てられるようになります。

コードベースも TypeScript で書かれています。これは新しいコードベースにコントリビューションするために TypeScript の熟練が必要になることを意味するが、型情報と IDE のサポートにより、新しいコントリビュータがより簡単に有意義なコントリビューションができるようになると確信しています。

observer と scheduler を個別のパッケージに分離することで、これらの部分の代替の実装を簡単に試すことができるようになります。たとえば IE11 互換の observer 実装を同じ API で実装できるし、`requestIdleCallback` を使って時間のかかる処理を行う代替スケジューラを実装することもできます。

> ![](https://cdn-images-1.medium.com/max/1600/1*H8yM0usFhWYlY6GV2wcrEw.png "新しいソースコード構造をチラ見せ (変わるかも)")
> 新しいソースコード構造をチラ見せ (変わるかも)

## 監視メカニズム

*TL;DR: より完全・正確・効率的・デバッグ可能なリアクティブトラッキングおよび observables を作成するための API*

3.0 には Proxy ベースの observer 実装が付属しています。これは完全な言語カバレッジを持つリアクティブトラッキングを提供します。これにより、`Object.defineProperty` に基づいた Vue 2 の現在の実装における多くの制限が解消される:

- プロパティの追加 / 削除の検出

- Array のインデックスの変更 / `.length` の変化の検出

- Map, Set, WeakMap, WeakSet のサポート

新しい observer には以下の機能もあります:

- observables を作成するための公開 API。これにより、中小規模のシナリオに対応する、軽量でシンプルなクロスコンポーネント状態管理ソリューションが提供されます。

- Lazy Observation がデフォルトになります。2.x ではあらゆるリアクティブなデータが、その大小に関係なく、起動時に observe されていました。データセットが巨大ならば、アプリの起動に顕著なオーバーヘッドを引き起こす可能性があります。3.x では、アプリケーションの最初に表示される部分をレンダリングするために使用されるデータだけが observe されるようになり、もちろん observation 自体もより高速になります。

- より正確な変更通知。例: 2.x では、`Vue.set` を使って強制的に新しいプロパティを追加すると、そのオブジェクトに依存するあらゆるウォッチャが再評価されます。3.x では、追加されたプロパティに依存するウォッチャにのみ通知されるようになります。

- Immutable observables: ネストされたプロパティにおいても不変な値が作成可能になります。こうした値はシステムによって内部的に、一時的にアンロックされる場合を除いて変更できません。このメカニズムは、渡された props を凍結したり、Vuex ステートツリーを mutation の外から変更できないようにするために使えます。

- より良いデバッグ機能: 新しい `renderTracked` フックと `renderTriggered` フックを使用して、コンポーネントの再レンダリングがいつ、なぜ track / trigger されるかをより正確にトレースすることができるようになります:

> ![](https://cdn-images-1.medium.com/max/1600/1*waSYB1v2aRgUFx21-JSwRg.png "なぜコンポーネントが再レンダリングされるのかを簡単に理解する")
> なぜコンポーネントが再レンダリングされるのかを簡単に理解する

## その他のランタイムの改善

*TL;DR: より小さく、速く、tree-shakable な機能、Fragment と Portal、カスタムレンダラ API。*

- より小さい: 新しいコードベースは、基本的に tree-shaking と相性が良いように設計されています。組み込みコンポーネント (`<transition>`, `<keep-alive>`) やディレクティブランタイムヘルパー (`v-model`) のような機能はオンデマンドに tree-shaking 可能にインポートされるようになりました。**新しいランタイムのサイズは基本的に &lt;10kb gzipped です**。 加えて、tree-shaking 可能なことにより、今後は使用しないユーザにペイロードのペナルティを課すことなく、より多くの組み込み機能を提供できます。

- より速い: 事前のベンチマークでは、raw Virtual DOM のマウント & パッチ (私たちは最速の Virtual DOM 実装、[Inferno](https://infernojs.org/) から多くのトリックを学びました), コンポーネントインスタンスの初期化とデータの observation を含み、全面的に最大で 100% のパフォーマンス向上が見られています。3.0 は、あなたのアプリが起動したときに JavaScript で費やされた時間の半分を削減します。

- Fragment と Portal: そのサイズが縮小されたにもかかわらず、3.0 には、Fragment（複数のルートノードを返すコンポーネント）と Portal（コンポーネント内ではなく DOM の別の部分にサブツリーをレンダリングする）の組み込みサポートが付属します。

- 改善された slot のメカニズム: コンパイラによって生成されたすべての slot は、子コンポーネントの render 呼び出し中に関数として呼び出されるようになります。これにより、slot の依存関係が親ではなく子の依存関係になることが保証されます。これは、次のことを意味します。1. slot の内容が変更された場合、子のみが再レンダリングされます。2. 親を再レンダリングしても、その slot の内容が変更されなければ、子は再レンダリングする必要はありません。この変更により、コンポーネントツリーレベルでより正確な変更の検出が提供されるため、無駄な再レンダリングはさらに少なくなりました！

- カスタムレンダラ API: カスタムレンダラを作成するためのファーストクラス API が利用可能になり、それらの改変のために Vue コードベースをフォークする必要はなくなりました。これにより、[Weex](https://weex-project.io/) や [NativeScript\-Vue](https://nativescript-vue.org/) などの render-to-native プロジェクトがアップストリームの変更に対して最新の状態に保ちやすくなります。また、さまざまな目的のためにカスタムレンダラを作成することが簡単になります。

## コンパイラの改良*

*TL;DR: tree-shaking と相性の良い出力、さらなる AOT 最適化、より良いエラー情報とソースマップをサポートしたパーサ。*

- tree-shaking-capable なバンドラを対象とし、テンプレートはオプション機能をインポートするために ES modules syntax を利用するようになります。これにより、未使用のオプション機能は、最終的なバンドルから削除されます。

- 新しい Virtual DOM 実装の改善により、より効果的なコンパイル時の最適化も実行できます。静的なツリーの巻き上げ (static tree hoisting), 静的な props の巻き上げ (static props hoisting), ランタイムで子の正規化をスキップするためのコンパイラヒント (compiler-hints for runtime to skip children normalization), VNode 生成に関するファストパス (VNode creation fast paths), etc...

- テンプレートのコンパイルエラーで位置情報を提供するためにパーサを書き直す予定があります。これは、テンプレートのソースマップのサポートにもつながるはずです。新しいパーサは、`eslint-plugin-vue` や IDE 言語サービスなど、サードパーティツールとのインテグレーションの基礎となります。

## IE11 サポート*

*TL;DR: サポートされる予定ですが、Vue 2.x と同じリアクティブ制限を持つ別のビルドになります。*

新しいコードベースは現在主要ブラウザのみを対象としており、ネイティブ ES2015 サポートを基本的な前提としています。しかし、悲しいことに、われわれは多くのユーザがもうしばらく IE11 をサポートする必要があることを知っています。ES2015 のほとんどの機能は、Proxy を除いて、IE11 用にトランスパイル／ポリフィルすることができるため、同一の API で、古い ES5 の `Object.defineProperty` API を使用して代替 observer を実装する予定です。この observer 実装を使用して、Vue 3.x の別のビルドが配布されますが、このビルドは、変更検出に関して Vue 2.x と同じ注意事項を残しているので、3.x の "modern" ビルドと完全には互換性がありません。これは2つの異なるビルドの互換性を認識する必要性に繋がり、これらがライブラリ作者にいくらかの不便を与えることを私たちは認識していますが、このステージに差し掛かった際には、明確なガイドラインを提供することを約束します。

# どのように到達するか

まず第一に、今日このような発表を行いましたが、明確なタイムラインは未だ存在しません。現時点で私たちが知っていることは、そこに到達するために取るべきステップです。

## 1. ランタイム・プロトタイプの内部フィードバック / Internal Feedback for the Runtime Prototype

これが現在のフェーズです。すでに、新しい observer、 Virtual DOM およびコンポーネント実装を含む、動作中のランタイム・プロトタイプが用意されています。私たちは、影響力のあるコミュニティプロジェクトの作者のグループを招いて、内部的な変更をフィードバックしてもらい、それらが快適だということをあらかじめ確認したいと思っています。私たちは、3.0 と重要なライブラリが同時にリリースされ、それらのプロジェクトに頼っているユーザが簡単にアップグレードできることを保証したいと思います。

## 2. RFC を通じた公開フィードバック

新しいデザインに一定のレベルの確信を得たら、破壊的な変更ごとに下記を含む専用の RFC issue を開くでしょう:

- 影響範囲

- 変更の根拠: 私たちは何を得て、どのようなトレードオフが行われているのか

- アップグレードパス: 完全に下位互換性のあるやり方で、リムーバブルな互換レイヤ経由で、あるいは codemods 経由で導入できるか？

これらのアイデアをまとめるために、より広範なコミュニティからのフィードバックを期待しています。


## 3. `2.x` と `2.x-next` に互換機能を導入する

2.x のことも忘れません！　と言うよりも、私たちは 2.x を使用してユーザに新しい変更を徐々に習得させる予定です。API の変更は opt-in アダプタを通じて 2.x に徐々に導入していき、またユーザは 2.x-next で新しい Proxy ベースの observer を試すことができるようになります。

2.x の最後のマイナーリリースは LTS になり、3.0 がリリースされても 18 ヶ月間にわたりバグとセキュリティ修正を受け続けます。

## 4. アルファ版

3.0 のコンパイラとサーバーサイド・レンダリングを完成させたら、アルファ版の作成を開始します。これらは主に、小さなグリーンフィールドの (訳注: まっさらな状態から作り始める) アプリ上での安定性テストの目的に使用されます。

## 5. ベータ版

ベータ段階では、Vue Router、Vuex、Vue CLI、Vue DevTools などのサポートライブラリとツールを更新して、新しいコアで円滑に動作するようにします。私たちは主要なライブラリの 3.0 対応を助けるべく、コミュニティ製ライブラリの作者とも協力していきます。

## 6. RC 版

API とコードベースが安定しているとみなしたら、API のフリーズを経て RC フェーズに入ります。このフェーズでは、2.x API の互換レイヤを含む 3.0 のビルド "compat build" に取り組みます。このビルドでは、フラグによって、アプリで 2.x API が使われている場合に deprecation warning を表示させることもできます。 compat build は、アプリを 3.0 にアップグレードするためのガイドとして使用できます。

## 7. IE11 ビルド

最終リリース前の最後のタスクは、上記の IE11 互換ビルドとなります。

## 8. 最終リリース

正直に申し上げて、これがいつになるかはまだ分からないですが、おそらく2019年内ではあります。また、決まった日にリリースをするよりも、堅実で安定したものを届けることを重要視しています。やるべきことは山積みですが、私たちは今後を楽しみにしています！
