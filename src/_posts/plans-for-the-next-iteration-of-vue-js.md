---
title: Vue.js における次のイテレーションの計画
date: 2018-10-01 00:00:00
---

# Vue.js における次のイテレーションの計画

先週の [Vue.js London](https://vuejs.london/summary/) で、私は Vue の次のメジャーバージョンについて簡単なプレビューを行った。このポストでは、計画の詳細な概要を提供する。

## なぜ新しいメジャーバージョンを？

Vue 2.0 はちょうど2年前にリリースされた（時が経つのは早いものだ！）。この期間中、core は下位互換性を維持しながら5つのマイナーリリースを行った。他にも改善をもたらすアイデアはあったが、それらは破壊的な変更を伴うために、延期されてきた。同時に、JavaScript エコシステムと言語そのものが急速に進化している。ワークフローを強化するツールが大きく改善されたこと、また多くの新しい言語機能によって、Vue が対処しようとしている問題を、より簡単・完全・効率的に解決できるようになった。エキサイティングなのは、ES2015 が主要なブラウザでサポートされるようになることだ。Vue 3.0 は、これらの新しい言語機能を活用して、Vue コアの小型化、高速化、および強力化を目指している。

Vue 3.0 は現在プロトタイプ段階にあり、私たちは既に 2.x で機能的に近いランタイムを実装している。**下記の項目の多くはすでに実装されているか、実行可能であることが確認されている。未だ実施されていないか、検討段階にあるものには*印がついている。**

# 詳細

## 高レベル API の変更

*TL;DR: render function API と scoped-slots syntax を除き、その全てが互換性を維持されているか、2.x 互換にすることができる。*

これは新しいメジャーバージョンであるため、いくつかの破壊的な変更が起こるだろう。しかし、私たちは下位互換性を真剣に受け止めているので、なるべく早くこれらの変更についてお知らせしたい。現在計画されている public API の変更点は次のとおり。

- テンプレートの構文は 99％ 今まで通りである。scoped-slots syntax には微妙な微調整があるかもしれないが、それ以外にテンプレートの変更は計画されていない。

- 3.0 は、あらゆる transpilation や stage-x features を必要とせずに、ネイティブ ES2015 で快適に使用できる API を提供することを目的として、クラスベースのコンポーネントをネイティブにサポートする。現在のほとんどのオプションは、クラスベースの API に妥当にマッピングされる。class fields や decorator などの stage-x features は、記述体験を向上させるためにオプションとして使用できるようになる。さらに、API は TypeScript 型推論を考慮して設計される。3.x コードベースそのものも TypeScript で記述され、改良されたTypeScript サポートが適用される。（とはいえ、アプリケーションで TypeScript を使用することは完全に任意である）

- 2.x のオブジェクトベースのコンポーネントは、内部的なクラスベースへの変換を通じて引き続き利用可能である。

- Mixins はサポートされ続ける。 *

- トップレベル API が大幅に見直され、プラグインのインストール時に Vue ランタイムをグローバルに変更しなくなる代わりに、プラグインはコンポーネントツリーに対して適用 (applied and scoped) される。これにより、特定のプラグインに依存するコンポーネントのテストが容易になるほか、異なるプラグインを扱う複数の Vue アプリケーションを1つのページにマウントすることが単一の Vue ランタイムで可能になる。*

- 関数型コンポーネントは遂に単なる関数になる。ただし、非同期コンポーネントに関してはヘルパ関数を使って明示的に作成する必要がある。

- 最も多くの変更を受ける部分は、render 関数の中で使われる Virtual DOM のフォーマットである。私たちは現在、主要なライブラリ作者からのフィードバックを集めており、変更内容が確固たるものになり次第詳細を共有するが、あなたが手書きの (JSX でない) render 関数に大きく依存していない限りは、そこそこ明快にアップグレードできるはずだと考えている。

## ソースコードアーキテクチャ

*TL;DR: より良く分離された内部モジュール、TypeScript、よりコントリビューションしやすくなるコードベース。*

よりクリーンでメンテナブルなアーキテクチャのために、私たちは 3.0 を最初から書き直している。特に、よりコントリビューションしやすくなることを心がけている。また複雑さのスコープを分割するため、いくつかの内部機能を個々のパッケージへと切り出している。たとえば、observer モジュールは独自のパブリック API とテストを持つ独自のパッケージになる。しかしこれらは、framework-level-API には影響しない。Vue を使用するために個々のパッケージをいちいちインポートする必要もなく、最終的な Vue のパッケージがそれらの内部パッケージを使って組み立てられるようになる。

コードベースも TypeScript で書かれている。これは新しいコードベースにコントリビューションするために TypeScript の熟練が必要になることを意味するが、型情報と IDE のサポートにより、新しいコントリビュータがより簡単に有意義なコントリビューションができるようになると確信している。

observer と scheduler を個別のパッケージに分離することで、これらの部分の代替の実装を簡単に試すことができるようになる。たとえば IE11 互換の observer 実装を同じ API で実装できるし、`requestIdleCallback` を使って時間のかかる処理を行う代替スケジューラを実装することもできる。

> ![](https://cdn-images-1.medium.com/max/1600/1*H8yM0usFhWYlY6GV2wcrEw.png "新しいソースコード構造をチラ見せ (変わるかも)")
> 新しいソースコード構造をチラ見せ (変わるかも)

## 監視メカニズム

*TL;DR: より完全・正確・効率的・デバッグ可能なリアクティブトラッキングおよび observables を作成するための API*

3.0 には Proxy ベースの observer 実装が付属している。これは完全な言語カバレッジを持つリアクティブトラッキングを提供する。これにより、`Object.defineProperty` に基づいた Vue 2 の現在の実装における多くの制限が解消される:

- プロパティの追加 / 削除の検出

- Array のインデックスの変更 / `.length` の変化の検出

- Map, Set, WeakMap, WeakSet のサポート

新しい observer には以下の機能もある:

- observables を作成するための公開 API。これにより、中小規模のシナリオに対応する、軽量でシンプルなクロスコンポーネント状態管理ソリューションが提供される。

- Lazy Observation がデフォルトになる。2.x ではあらゆるリアクティブなデータが、その大小に関係なく、起動時に observe されていた。データセットが巨大であれば、アプリの起動に顕著なオーバーヘッドを引き起こす可能性がある。3.x では、アプリケーションの最初に表示される部分をレンダリングするために使用されるデータだけが observe されるようになり、もちろん observation 自体もより高速になる。

- より正確な変更通知。例: 2.x では、`Vue.set` を使って強制的に新しいプロパティを追加すると、そのオブジェクトに依存するあらゆるウォッチャが再評価される原因となる。3.x では、特定のプロパティに依存するウォッチャにのみ通知されるようになる。

- Immutable observables: ネストされたプロパティにおいても不変な値が作成可能になる。それは内部的に、一時的にアンロックされる場合を除いて変更できない。このメカニズムは、渡された props を凍結したり、Vuex ステートツリーを mutation の外から変更できないようにするために使える。

- より良いデバッグ機能: 新しい `renderTracked` フックと `renderTriggered` フックを使用して、コンポーネントの再レンダリングがいつ、なぜ track / trigger されるかをより正確にトレースすることができるようになる:

> ![](https://cdn-images-1.medium.com/max/1600/1*waSYB1v2aRgUFx21-JSwRg.png "なぜコンポーネントが再レンダリングされるのかを簡単に理解する")
> なぜコンポーネントが再レンダリングされるのかを簡単に理解する

## その他のランタイムの改善

*TL;DR: より小さく、速く、tree-shakable な機能、Fragment と Portal、カスタムレンダラ API。*

- より小さい: 新しいコードベースは、基本的に tree-shaking と相性が良いように設計されている。組み込みコンポーネント (`<transition>`, `<keep-alive>`) やディレクティブランタイムヘルパー (`v-model`) のような機能はオンデマンドに tree-shaking 可能にインポートされるようになった。**新しいランタイムのサイズは基本的に &lt;10kb gzipped である**。 加えて、tree-shaking 可能であることにより、今後は使用しないユーザにペイロードのペナルティを課すことなく、より多くの組み込み機能を提供できる。

- より速い: 事前のベンチマークでは、raw Virtual DOM のマウント & パッチ (私たちは最速の Virtual DOM 実装である [Inferno](https://infernojs.org/) から多くの細やかなトリックを学んだ), コンポーネントインスタンスの初期化とデータの observation を含み、全面的に 100% のパフォーマンス向上が見られている。3.0は、あなたのアプリが起動したときに JavaScript で費やされた時間の半分を削減する。

- Fragment と Portal: そのサイズが縮小されたにもかかわらず、3.0には、Fragment（複数のルートノードを返すコンポーネント）と Portal（コンポーネント内ではなく DOM の別の部分にサブツリーをレンダリングする）の組み込みサポートが付属する。

- 改善された slot のメカニズム: コンパイラによって生成されたすべての slot は、子コンポーネントの render 呼び出し中に関数として呼び出されるようになる。これにより、slot の依存関係が親ではなく子の依存関係になることが保証される。これは、次のことを意味する。1. slot の内容が変更された場合、子のみが再レンダリングされる。2. 親を再レンダリングしても、その slot の内容が変更されなければ、子は再レンダリングする必要はない。この変更により、コンポーネントツリーレベルでより正確な変更の検出が提供されるため、無駄な再レンダリングはさらに少なくなった！

- カスタムレンダラ API: カスタムレンダラを作成するためのファーストクラス API が利用可能になり、それらの改変のために Vue コードベースをフォークする必要はなくなった。これにより、[Weex](https://weex-project.io/) や [NativeScript\-Vue](https://nativescript-vue.org/) などの render-to-native プロジェクトがアップストリームの変更を最新の状態に保ちやすくなる。また、さまざまな目的のためにカスタムレンダラを作成することが簡単になる。

## コンパイラの改良*

*TL;DR: tree-shaking と相性の良い出力、さらなる AOT 最適化、より良いエラー情報とソースマップをサポートしたパーサ。*

- tree-shaking-capable なバンドラを対象とし、テンプレートはオプション機能をインポートするために ES modules syntax を利用するようになる。これにより、未使用のオプション機能は、最終的なバンドルから削除される。

- 新しい Virtual DOM 実装の改善により、より効果的なコンパイル時の最適化も実行できる。
    - static tree hoisting
    - static props hoisting
    - compiler-hints for runtime to skip children normalization
    - VNode creation fast paths
    - etc...

- テンプレートのコンパイルエラーで位置情報を提供するためにパーサを書き直す予定がある。これは、テンプレートのソースマップのサポートにもつながるはずである。新しいパーサは、`eslint-plugin-vue` や IDE 言語サービスなど、サードパーティツールとのインテグレーションの基礎となる。

## IE11 サポート*

*TL;DR: サポートされる予定だが、Vue 2.x と同じリアクティブ制限を持つ別のビルドになる。*

新しいコードベースは現在主要ブラウザのみを対象としており、ネイティブ ES2015 サポートを基本的な前提としている。しかし、悲しいかな、われわれは多くのユーザがもうしばらく IE11 をサポートする必要があることを知っている。ES2015 のほとんどの機能は、Proxy を除いて、IE11 用にトランスパイル／ポリフィルすることができるため、同一の API で、古い ES5 の `Object.defineProperty` API を使用して代替 observer を実装する予定である。この observer 実装を使用して、Vue 3.x の別のビルドが配布されるが、このビルドは、Vue 2.x の同じ変更検出に関する注意事項の対象となるため、3.x の "modern" ビルドと完全には互換性がない。これは2つの異なるビルドの互換性を認識する必要性に繋がり、これらがライブラリ作者にいくらかの不便を与えることを私たちは認識しているが、このステージに差し掛かった際には、明確なガイドラインを提供することを約束する。

# どのように到達するか

まず第一に、今日このような発表を行ったが、明確なタイムラインは未だ存在しない。現時点で私たちが知っていることは、そこに到達するために取るべきステップである。

## 1. ランタイム・プロトタイプの内部フィードバック / Internal Feedback for the Runtime Prototype

これが現在のフェーズである。すでに、新しい observer、 Virtual DOM およびコンポーネント実装を含む、動作中のランタイム・プロトタイプが用意されている。私たちは、影響力のあるコミュニティプロジェクトの著者のグループを招いて、内部的な変更をフィードバックしてもらい、それらが快適であることをあらかじめ確認したいと思っている。私たちは、3.0 と重要なライブラリが同時にリリースされ、それらのプロジェクトに頼っているユーザが簡単にアップグレードできることを保証したい。

## 2. RFC を通じた公開フィードバック

新しいデザインに一定のレベルの信頼を得たら、破壊的な変更ごとに下記を含む専用の RFC issue を開くだろう:

- 影響範囲

- 変更の根拠: 私たちは何を得て、どのようなトレードオフが行われているのか

- アップグレードパス: 完全に下位互換性のあるやり方で、リムーバブルな互換レイヤ経由で、あるいは codemods 経由で導入できるか？

これらのアイデアをまとめるために、より広範なコミュニティからのフィードバックを期待している。


## 3. `2.x`と` 2.x-next`に互換機能を導入する

2.x のことも忘れないよ！　私たちは実際には、2.x を使用してユーザに新しい変更を徐々に習得させる予定だ。API の変更を opt-in アダプタによって 2.x に徐々に導入し、2.x-next で新しい Proxy ベースの observer を試すことができる。

2.x の最後のマイナーリリースは LTS になり、3.0 がリリースされても 18 ヶ月間にわたりバグとセキュリティ修正を受け続ける。

## 4. アルファ版

3.0 のコンパイラとサーバーサイド・レンダリングを完成させたら、アルファ版の作成を開始する。これらは主に、小さなグリーンフィールドの (訳注: まっさらな状態から作り始める) アプリの安定性テストの目的に使用される。

## 5. ベータ版

ベータ段階では、Vue Router、Vuex、Vue CLI、Vue DevTools などのサポートライブラリとツールを更新して、新しいコアで円滑に動作するようにする。私たちはコミュニティの主要なライブラリ作者と協力して、彼らが 3.0 の準備を整えるのを手伝っていく。

## 6. RC 版

API とコードベースが安定しているとみなしたら、API のフリーズを経て RC フェーズに入る。このフェーズでは、2.x API の互換レイヤを含む 3.0 のビルドである "compat build" に取り組む。このビルドには、アプリでの 2.x API の使用に関する deprecation warnings を表示するためのフラグを付けることもできる。compat build は、アプリを 3.0 にアップグレードするためのガイドとして使用できる。

## 7. IE11 ビルド

最終リリース前の最後のタスクは、上記の IE11 互換ビルドとなる。

## 8. 最終リリース

正直に言うと、これがいつになるかはまだ分からないが、たぶん2019年内ではあるね。また、特定の日付を決めるよりも、堅実で安定したものを届けることを重要視している。やるべきことは山積みだが、私たちは次に来るものに興奮しているよ！
